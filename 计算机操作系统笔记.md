# 计算机系统概述
---
## 操作系统概念
### 概念：
操作系统特征：
- 并发：可同时处理多个程序
- 共享：资源可被多个并发进程共用
- 虚拟：将物理实物虚拟为逻辑对应
- 异步：任务可以不按固定的顺序执行
操作系统功能：
- 作为用户语句计算机硬件系统之间的接口
- 作为计算机系统资源的管理者
- 实现对计算机资源的抽象化

### 计算机系统的发展：
- 手工操作
- 批处理操作
- 分时操作
- 实时操作

### 操作系统引导：
![[Pasted image 20251224154654.png]]
1. 电源开机
2. BIOS/UEFI阶段
3. 引导加载器
4. 加载操作系统内核
5. 内核初始化
6. 启动系统服务和守护进程

## 程序运行环境
### CPU运行模式：
- 内核模式：可执行一切指令，访问所有硬件资源
- 用户模式：只能执行受限的指令，访问有限的硬件资源
内核模式：
- 完全权限
- 核心功能
- 上下文交换
- 高风险
特权指令：
- 硬件控制
- 内存管理
- 进程管理
- I/O操作
- 系统调用

用户模式：
- 权限受限
- 隔离性
- 安全性
- 执行方式
![[Pasted image 20251224155104.png]]
### 系统调用：
系统调用是运行在用户模式的应用程序与操作系统内核之间的接口。当应用程序需要执行一些它在用户模式下不能直接完成的任务时，它可以通过系统调用来请求操作系统内核在内核模式下为其执行这些操作。
当用户触发了系统调用时，CPU会自动切换到内核态，将控制权交给操作系统。操作系统执行完成后再通过指令切回用户态。

### 程序的链接：
程序的链接是将编译后的代码模块（通常是目标文件）和其他所需的库组合在一起，生成一个可以执行的程序或库的过程。链接过程由链接器完成。

静态链接：
依赖直接作为二进制被打包进最后的可执行程序中，所以可以直接跨机器运行。
动态链接：
程序只保存依赖的库地址，依赖与可执行程序分开保存，当程序执行时再去动态地加载依赖库。拷贝可执行程序到另一台机器不一定能直接运行，这需要另外一台机器也保存有相应依赖。

### 程序的装入：
程序的装入是指将程序或进程的代码和数据从磁盘加载到主存（RAM）中的过程，使其准备好被 CPU 执行。装入过程在程序执行周期中是必不可少的一部分，通常由操作系统中的装入器完成。

## 操作系统结构
### 分层和模块化：
![[Pasted image 20251224155946.png]]
分层结构：
将系统分层，每层都为上层提供服务，并依赖于下层。
模块化结构：
将操作系统分为模块，每个模块都有特定功能，各个模块之间的交互通过定义良好的接口进行。

### 内核架构：
微内核：
微内核是一种最小化的内核设计，只保留最核心的功能（如线程管理、虚拟内存、进程间通信等）在内核态运行，其他功能（如文件系统、设备驱动、网络协议栈等）以用户态服务的形式运行。
宏内核：
宏内核将所有操作系统功能集成在一个大的内核程序中，运行在内核态。
![[Pasted image 20251224160435.png]]

### 虚拟机：
虚拟机是一种通过软件模拟真实计算机功能的虚拟化技术，能够在一台物理主机上创建多个独立的虚拟计算机环境。每个虚拟机都具备与真实硬件相似的运行环境，可以运行独立的操作系统和应用程序，仿佛它们运行在专属的物理设备上。
![[Pasted image 20251224160517.png]]
虚拟机监视器：
是虚拟化技术的核心组件，运行在物理主机和虚拟机之间的中间软件层。它负责协调和管理多个虚拟机，使它们能够共享底层物理硬件资源，同时保持彼此隔离。特权级比操作系统更高。

# 进程管理
---
## 进程与线程

### ==进程：==
进程是系统资源分配的基本单位。进程拥有独立的系统资源，包括内存空间、文件描述符、CPU 时间片等，这些资源的分配由操作系统负责。

- **程序**
    - 程序是一组指令的静态集合，它存储在磁盘等持久性存储介质中。
    - 程序是被动的，它本身并不执行任何操作。
    - 一个程序可以多次运行，每次运行都会创建一个新的进程。
- **进程**
    - 进程是程序在内存中执行的实例。
    - 当一个程序被加载到内存中并开始执行时，操作系统会创建一个进程。
    - 进程是动态的，它代表了程序的执行过程。

进程控制块PCB：
操作系统通过进程控制块对进程进行管理，进程控制块中包含一系列进程的元信息，这些元信息帮助操作系统对进程进行管理。
- 进程创建和终止
- 进程调度

进程元信息：

| 进程描述信息     | 进程控制和管理信息 | 资源分配清单 | 处理机相关信息 |
| ---------- | --------- | ------ | ------- |
| 进程标识符（PID） | 进程状态      | 代码段指针  | 通用寄存器值  |
| 用户标识符（UID） | 进程优先级     | 数据段指针  | 地址寄存器值  |
|            | 代码运行入口地址  | 堆栈段指针  | 控制寄存器值  |
|            | 程序的外存地址   | 文件描述符  | 标志寄存器值  |
|            | 等待时间      |        |         |
|            | CPU 占用时间  |        |         |

父子进程：
在操作系统中，进程是程序执行的基本单位。父子进程是指通过进程创建机制生成的一种层级关系。
子进程通常由父进程通过fork系统调用建立。子进程是父进程的副本，继承父进程的代码段、数据段、堆栈等资源，但拥有自己的独立地址空间和执行状态。两者可以通过进程间通信（IPC）机制（如管道、信号、共享内存）进行数据交换或同步。

僵尸进程：
指一个已经终止（完成了其执行）的子进程，但其父进程尚未通过 wait 或 waitpid 系统调用回收其退出状态。僵尸进程虽然不再运行，但仍在进程表中保留一个条目，占用系统资源，直到父进程回收或父进程终止。

孤儿进程：
指父进程在子进程终止前退出，导致子进程失去父进程的进程。孤儿进程与僵尸进程不同，它仍在运行，只是失去了原来的父进程。

### ==线程：==
线程是系统调度的基本单位。多核处理器可以将系统中的不同线程调度到不同的CPU逻辑核心上，所以在同一个时刻，系统中的线程可能会在不同的逻辑核心上并行运行。每个进程启动的时候，都包含一个线程（主线程），可以在主线程外创建更多的线程。
一个进程中的所有线程都共享虚拟地址空间和系统资源，但是每个线程都维护自己的堆栈、寄存器和一些额外信息。

在一个进程中没有创建线程时，则该进程为单线程进程，否则该进程中包含多个线程。
![[Pasted image 20251224210954.png]]

### ==进程状态：==
状态种类：
1. 创建状态（New）：进程被创建但还未分配资源或执行
2. 就绪状态（Ready）：进程已准备好执行，但由于操作系统调度算法或其他原因，尚未获得CPU时间片。
3. 运行状态（Running）：进程正在执行指令并占用CPU。
4. 阻塞状态（Blocked）：当进程在等待某些事件发生时，如等待I/O操作完成或等待其他资源时，它会进入阻塞状态。在阻塞状态下，进程暂停执行，直到等待的事件发生。
5. 终止状态（Terminated）：进程执行完毕或被操作系统终止。

状态转化：
![[Pasted image 20251224211135.png]]
1. 就绪态→运行态
    - 调度：操作系统的调度器选择一个就绪状态的进程分配给处理器。
2. 运行态→就绪态
    - 时间片用完：如果系统使用时间共享调度，当进程的时间片用完，它会被中断并放回就绪队列。
    - 优先级更高的进程就绪：在优先级调度算法中，如果一个优先级更高的进程变为就绪状态，当前运行的进程可能会被挂起。
    - 自愿放弃CPU：进程可能主动放弃CPU，比如它发出了一个系统调用请求其他资源。
3. 运行态→阻塞态
    - I/O请求：进程进行I/O操作，由于I/O设备比CPU慢得多，进程会被挂起直到I/O完成。
    - 等待资源：进程等待不可用的资源，如信号量、互斥锁等。
    - 等待事件：如等待其他进程的信号、消息或者某个条件的发生。
4. 阻塞态→就绪态
    - I/O完成：当I/O操作完成，相应的进程会被移至就绪队列。
    - 资源获得：进程所等待的资源变得可用，如获得了互斥锁。
    - 事件发生：进程所等待的事件发生了，如接收到了另一个进程发出的信号。

### ==进程内存空间：==
- 用户空间：包含进程执行的用户程序代码和数据。在用户空间中，进程可以执行各种任务，如运行应用程序、访问文件系统等。用户空间对于应用程序是可见的，但对于操作系统中的核心功能是不可见的。
    1. 代码区：也称为“可执行代码区”，存储了进程的可执行代码，包括程序的指令和只读数据。这个区域通常是只读的，因为程序的指令在运行时不应被修改。
    2. 数据区：
        - 初始化数据区：存储全局和静态变量以及初始化的数据。这些变量在程序运行前就已经分配了内存并初始化。
        - 未初始化数据区，也称为BSS段，存储全局和静态变量，但这些变量没有显式的初始化值。操作系统会在程序启动时自动将这个区域初始化为零。
    3. 堆区：堆区是动态分配内存的地方，用于存储程序运行时需要的变量和数据结构。在堆中分配的内存需要手动释放，以避免内存泄漏。
    4. 栈区：栈区用于存储函数调用和局部变量。每个函数调用都会在栈上创建一个栈帧，栈帧包含了函数的参数、局部变量以及函数返回地址。
    5. 内存映射区域：这是一些操作系统或运行时库的扩展，用于存储动态链接库DLL和共享库的信息以及其他系统数据结构。
- 内核空间：内核空间包含了操作系统的核心代码和数据结构，如页表、调度程序和系统调用接口等。内核空间具有更高的特权级别，可以执行特权指令并且访问系统的各种资源，内核空间对于用户程序是不可见的。

函数调用时内存结构：
EBP (base pointer) 指向函数栈（栈帧）的底部（高地址），函数执行过程中在栈帧中分配局部变量，栈帧由高地址向低地址增长，ESP（stack pointer）一直指向栈顶。
每个函数的栈帧中包含如下内容：
- 上一个函数的 EBP
- 该函数的局部变量
- 如果函数内有 `call` 指令的话，还需要保存额外信息：
    - 下一个函数的参数：依次存储从第 n 个到第 1 个，从高地址到低地址
    - 返回地址：当前 PC 指向的位置，即 `call` 指令的下一条指令的地址
在函数的调用过程中，调用函数叫做 caller，被调用函数叫做 callee。当我们从 caller 中调用 callee 时，callee 的 EBP 指向的物理地址的上下存储单元分别包含 caller 的返回地址以及 caller 所在栈帧的 EBP，当我们在 callee 中执行 `ret` 指令时，计算机可以跳转到 caller 中 `call` 指令的下一条并开始执行，同时 caller 的栈帧也会被恢复。


### 进程间通信：
指在同一计算机系统中，两个或多个进程之间交换数据或信号的机制。常见的进程间通信方式主要包含共享内存、管道、消息队列、信号、套接字和信号量。

管道：
主要用于具有亲缘关系的进程之间的数据传递。无名管道只能在父子进程或兄弟进程之间使用；有名管道通过文件系统中的特殊文件实现，不要求通信双方有亲缘关系。
以字节流的形式传递数据，先进先出，只支持单向通信，效率较低。

共享内存：
允许多个进程将同一段物理内存映射到各自的虚拟地址空间中，从而直接读写该区域的数据。
由于不需要内核频繁介入，通信效率极高，非常适合大规模数据的快速传输。然而，由于多个进程可同时访问内存区域，必须通过额外的同步机制如信号量或互斥锁来确保数据一致性，否则容易出现竞争条件和数据错误。

信息队列：
基于内核的数据结构，允许多个进程以消息为单位进行通信，具有良好的结构化和独立性。进程通过系统调用将消息发送到队列中或从中接收消息，可以实现同步与异步的通信模式。
相比管道，消息队列的通信更加灵活，支持优先级管理，适用于需要有序、分类传输数据的场景。但由于涉及内核操作，性能开销相对共享内存较大。

### 用户级线程和内核级线程：
用户级线程（ULT，User Level Thread）
用户级线程是由应用程序通过线程库来实现的，操作系统内核并不直接感知到这些线程的存在。
线程的创建、调度和管理都由应用程序在用户空间完成。
内核级线程（KLT，Kernel Level Thread）
内核级线程是由操作系统内核直接支持的线程。
线程的创建、调度和管理都由操作系统内核完成。

线程模型：
- 纯用户态
- 纯系统态
- 混合方案
混合方案中的映射关系：
- 一对一
- 多对一
- 多对多

## 处理机调度
### 调度指标：
调度是把CPU时间合理分配给多个进程或线程的核心机制。调度的好坏直接决定系统的响应速度、吞吐能力以及资源利用效率。为了衡量调度策略的优劣，我们通常用一组调度指标来量化：
- 系统层面的宏观指标：
	- CPU的利用率
	- 系统整体吞吐量
- 进程层面的微观指标：
	- 到达时间AT
	- 等待时间WT
	- 要求服务时间BT
	- 完成时间CT
	- 周转时间TAT：`TAT=CT-AT=WT+BT
![[Pasted image 20251227123903.png]]


### 系统调度过程：
![[Pasted image 20251227124241.png]]
1. 高级调度（长程调度）：
	- 功能：决定哪些进程应该被加载到内存中称为一个可运行的进程。
	- 主要目标：保持内存中适当数量的进程。
	- 当进程首次进入系统时，它们首先被放置在磁盘的一个区域，称为作业池。高级调度器从作业池中选择进程，根据某种策略将其加载到内存中，从而使其成为一个可运行的进程。
2. 中级调度（中程调度）：
	- 功能：决定哪些进程应该从内存移除到磁盘上。
	- 主要目标：为高级调度和初级调度优化内存。
3. 初级调度（短程调度）：
	- 功能：决定哪些进程应当被赋予CPU时间片，即决定下一个运行在处理器上的进程。
	- 主要目标：确保CPU的高效利用。

### 调度的实现：
调度器/调度程序：
在操作系统中负责决定下一个要执行的进程或线程的部分。通常分为长、中、短程调度器。
调度时机：
- 进程进入或退出系统
- 进程从运行状态变为阻塞状态
- 一个时间片结束
调度方式：
- 抢占式调度：中断当前进程
- 非抢占式调度：等待当前进程结束
闲逛进程：
是操作系统中的一个特殊进程，当系统没有任何其他可运行的进程时，调度器会将CPU的控制权交给这个进程。闲逛进程的主要目的是确保在没有任务可执行的情况下，CPU不会空转，从而防止CPU进入不受控制的状态。
两种线程的调度：
- 内核级线程：由操作系统内核直接支持的线程。操作系统知道这些线程的存在，并可以直接进行调度。
- 用户级进程：完全在用户空间中实现的线程，内核无法检测到和直接调度。

### 调度算法：
- 抢占型调度算法：时间片轮转、多级反馈队列
- 非抢占型调度算法：先来先服务、最短任务优先、最高响应比优先

优先级调度：
- 抢占式优先级调度
- 非抢占式优先级调度
![[Pasted image 20251227130844.png]]


先来先服务FCFS：
按照进程到达顺序依次执行。
最短作业优先SJF：
算法在就绪队列中选择进程时选择运行时间最短的进程执行。
最高响应比优先HRRN：
选响应比$(W+B)/B$最高的进程执行，其中$W$为进程的等待时间，$B$为进程的要求服务时间。
时间片轮转RR：
每个进程分配一个固定的时间片，时间片用完后将进程放回队列尾部。
多级反馈队列MFQ：
这是一种混合算法，将进程分为多个队列，每个队列有不同的优先级和时间片大小。
高优先级队列优先调度，时间片较短，适合交互型进程；低优先级队列时间片较长，适合计算密集型任务。新进程通常进入最高优先级队列，若在时间片内未完成，则移到下一级队列；若因 I/O 等待阻塞，完成后可能返回较高优先级队列。

### 上下文切换：
进程的上下文是进程执行的环境。在操作系统中，它指的是一个进程在特定时间点上的系统状态，包括多种信息，这些信息使得进程在被中断后可以再次恢复并继续执行。当操作系统从一个进程切换到另一个进程时，它会保存当前进程的上下文并恢复下一个进程的上下文。这个过程被称为上下文切换。
![[Pasted image 20251227131411.png]]
进程上下文内容：
- 寄存器值
- 程序计数器
- 虚拟内存信息
- I/O状态信息
- CPU调用信息
- 资源使用情况
上下文切换流程：
- 保存当前进程的状态
- 选择下一个要执行的进程
- 恢复下一个进程的状态
- 开始执行新进程

## 同步和互斥
### 临界区和互斥概念：
在并发编程中，临界区（Critical Section）是指一个程序中仅允许一个线程或进程访问的代码片段。这些代码通常会访问共享资源，比如内存、文件、数据库等。当多个线程或进程试图同时访问这些共享资源时，可能会导致数据不一致或其他并发问题。因此，需要一种机制来确保在任何时候，保证在一个时刻只有一个线程或进程能够访问临界区的代码。这种机制就叫做互斥。
互斥（Mutual Exclusion）是计算机科学中一种用于防止多个进程或线程同时访问共享资源或临界区的机制。其主要目标是避免资源竞争和数据不一致的问题。互斥保证在任何时刻，最多只有一个线程或进程可以访问特定的共享资源，从而确保数据的完整性。

临界资源：
可被多个线程或进程同时访问的系统资源即为临界资源，也称为共享资源。

互斥的必要性：
临界区涉及到对于临界资源的访问，如果多个线程同时执行临界区代码访问临界资源时，实际执行的指令序列就具有不可预测性，结果也因此常常出现不一致的情况。
为了解决以上问题，多线程在访问临界资源时必须是互斥的。也就是说，当一个线程在访问临界资源的过程中，不允许其他线程再访问临界资源。其他线程必须等待到当前访问者访问完，才能进入临界区。

### 互斥：
实现互斥的方法：
- 软件互斥
- 硬件互斥
- 锁
- 信号量

互斥锁Mutex：
一种机制。确保在任何时刻只有一个线程能够拥有该锁，确保临界资源的安全访问。
任何时候，只有一个线程可以持有互斥锁。其它试图获取该锁的线程将被阻塞，直到持有锁的线程 释放该锁。只有锁的持有者才能释放它。这确保了非持有者不能误释放锁。
互斥锁有两个操作：
- 加锁
- 解锁
![[Pasted image 20251227135113.png]]

软件互斥：
依赖算法和程序设计确保资源的独占访问，主要通过逻辑控制和变量来实现。使用Peterson算法：
基于两个线程之间的竞争条件来实现互斥。使用两个布尔变量和一个整数变量分别表示两个线程的意愿和当前正在运行的线程。

硬件互斥：
使用CPU指令集中的原子指令来实现软件互斥类似的功能。
使用原子指令实现的锁一般叫做自旋锁，因为加锁的过程需要不断地执行原子指令，可能会大量占用CPU。

> [!info]
> 
> **原子性和原子指令：**
> 原子性是指一个操作是不可分割的，要么完全执行，要么完全不执行。在多线程或多进程环境中，原子性确保操作不会被其他并发操作中断。
> 原子指令，是计算机体系结构中的一种特殊指令，它们被设计为在单个处理器指令周期内执行完毕，不会被中断或其他线程干扰。

- TAS指令实现方式
- CAS指令实现方式

### 同步
同步是指多个线程为了协同完成某项任务，必须按照一定的顺序执行操作。它主要解决线程之间在执行过程中如何协调的问题，确保它们以预期的时序进行交互与合作。

同步原则：
- 空闲让进：如果没有其他线程处于临界区，则允许当前线程进入；
- 忙则等待：若已有线程在临界区，则其他线程必须等待；
- 有限等待：每个等待进入临界区的线程都有机会在有限时间内进入，避免 “死等”；
- 让权等待：不能进入临界区的线程应主动放弃 CPU（如进入等待队列），避免 “忙等”。

死等状态：进程或线程长期得不到临界区的访问权
忙等状态：进程或线程未能进入临界区，但却反复占用CPU执行检查操作

条件变量：
用于在多线程之间进行有条件的协作。它允许线程在某个条件未满足时进入等待状态，并在等待期间自动释放已持有的锁，从而让其他线程有机会获取该锁并修改共享数据，使条件得以满足。
条件变量提供三种操作：
- `wait()`：使调用它的线程休眠，直到另一个线程来唤醒它。
- `signal()`：用于唤醒等待在条件变量上的某个进程。
- `broadcast()/notify_all()`：唤醒所有等待在条件变量上的线程。

信号量：
![[Pasted image 20251227143013.png#center]]
用于表示可用资源的数量。
信号量提供两个原子操作：
- `P`：申请资源，若信号量>0时减1，继续；否则阻塞。
- `V`：释放资源，若原值为0，唤醒一个阻塞进程；否则信号量加1。
信号量应用：
- 实现锁
- 实现简单同步
- 实现前驱关系

### 管程：
本质上是一种对互斥 + 条件同步的高级封装机制，通过结构化编程方式将“对共享资源的访问”与“同步控制”统一封装成一个模块，提升了程序的安全性和可读性。

## 死锁
### 死锁产生的必要条件：
需要同时满足：
- 互斥条件：至少有一个资源必须处于非共享模式。
- 占有并等待：一个进程因请求资源而阻塞时，不释放已有的资源。
- 非抢占：资源不能被抢占。
- 循环等待：一个进程资源的等待链，每一个进程都在等待下一个进程所持有的资源。

### 死锁处理策略：
- 死锁预防
- 死锁避免
- 死锁的检测和接触

### 死锁预防：
![[Pasted image 20251227144012.png]]
1. 破坏互斥条件
    - 互斥条件在某些情况下是不可避免的，例如打印机等硬件资源。但在某些场景下，通过资源复制或虚拟化技术，可以尝试减少资源的互斥使用。
2. 破坏占有并等待
    - 要求进程在开始时一次性申请其需要的所有资源。只有当所有资源都可用时，进程才被分配资源并开始执行。这样，进程在执行期间不会等待其他资源。
    - 如果进程申请新资源而被拒绝，则它必须释放所有已分配的资源，再重新申请。
3. 破坏非抢占
    - 当一个进程需要的资源被另一个进程所占有时，它可以抢占另一个进程的资源。
4. 破坏循环等待
    - 对进程申请资源的顺序进行限制。

### 死锁避免：
死锁避免是系统级的算法，需要对系统的资源和实体进行抽象，进行统筹规划。
![[Pasted image 20251227144712.png#center]]
`Available`：系统中每种资源的可用量。
`Max`：每个进程对每种资源的最大需求量。
`Allocation`：已经分配给每个进程的资源数量。
`Need`：每个进程还需要的资源数量。
![[Pasted image 20251227144911.png]]
安全分配序列：
安全分配序列是进程的一个排列，它保证了对于序列中的每个进程，当这些进程都申请 Need 中的全部资源时，系统都能够满足这些需求。如果系统存在一个安全分配序列，则系统处于安全状态。
安全性检查：
判断系统中是否至少存在一个安全分配序列。
![[Pasted image 20251227145229.png]]

### 死锁的检测和删除：
为了能对系统是否已发生了死锁进行检测，必须：
1. 用某种数据结构来保存资源的请求和分配信息：
2. 提供一种算法，利用上述信息来检测系统是否已进入死锁状态。
一般来说，一种简单的建模方式是使用资源分配图：
- 将系统中的所有资源和进程表示为图中的节点。
- 如果进程P1请求资源R1，绘制从P1到R1的有向边。
- 如果资源R1分配给了进程P2，绘制从R1到P2的有向边。
在构建完资源分配图，可以通过使用DFS检查图中是否存在环路以判断是否存在死锁。

# 内存管理
---
## 内存管理概念
### 内存管理：
内存共享：
共享内存是多个进程共享的内存区域。它是最快的IPC（进程间通信）机制之一，因为进程直接读写内存，无需进入内核态。但是，因为多个进程可以同时访问这些内存，所以可能需要某种同步机制来防止竞态条件。
内存保护：
内存保护是现代操作系统中的一个核心功能，用于防止一个进程访问另一个进程的内存空间。
![[Pasted image 20251227151148.png]]
- 分段：将内存划分为不同的段。
- 分页：将内存划分为固定大小的页面。
- 访问权限：每个段或页面都有与之相关的访问权限。
- 隔离：每个进程都有其独立的地址空间，一个进程不能直接访问另一个进程的内存。

管理方式分类：
- 连续分配
	- 单一连续分配
	- 固定分区分配
	- 动态分区分配
- 离散分配
	- 页式分配
	- 段式分配
	- 段页式分配
![[Pasted image 20251227151422.png]]

### 连续分配管理方式
单一连续分配：
![[Pasted image 20251227151932.png]]
内存被分为系统区和用户区。系统区仅供操作系统使用；用户区内存中只有一道用户程序，整个内存的用户空间都由该程序独占。
优点是简单、无外部碎片，无需进行内存保护。缺点是只能用于单用户、单任务的操作系统，存储器的利用率极低。

固定分区分配：
![[Pasted image 20251227151956.png]]

将用户内存空间划分为若干固定大小的区域，每个分区只装入一道作业。
通常将分区按大小排队，然后建立一张分区说明表，标明各分区的起始地址、大小和状态。
当有用户程序需要装入时，便检索该表，以找到合适的分区基于分配并将其状态设置为“已分配”；未找到合适分区时，则拒绝为给程序分配内存。

动态分区分配：
将内存堪称一整块连续的区域，每次分配的时候直接从其中的空闲区域申请一块内存。
申请过的内存可以释放，返回空闲内存池。
当进程申请内存时，操作系统会遍历空闲块表，根据设定的适应算法选择出空闲块，然后为进程分配所需的内存空间。

内存碎片：
由于各进程所需的内存大小各不相同，在进行内存分配时经常会在已分配的块之间留下内存碎片。内存碎片无法再次被利用。

适应算法：
内存空间中的空闲区域可能大小不一，且分布在内存中不同的位置，操作系统使用空闲块表来记录这些空闲区域的信息。
当进程申请一块新的内存时，必须从已有的空闲空间中选出一块分配给进程。动态分区的分配策略主要包含四种算法：
- 首次适应（First Fit）：从头遍历，找到第一个符合条件的空闲内存
- 临近适应（Next Fit）：从上次分配的位置向下寻找，找到第一个足够大的分区；否则从头遍历。
- 最佳适应（Best Fit）：遍历整个空闲块表，找到利用率最高的空闲内存。
- 最坏适应（Worst Fit）：遍历整个空闲块表，找到一个利用率最低的空闲内存。
![[Pasted image 20251227153303.png]]

内存回收过程：
伙伴算法：将内存分为大小为2的幂次方的块。没有合适的内存块时就将大块一分为二，直到满足需求。释放内存是会尝试将相邻块合并为更大的块以减少内存碎片。

### 离散分配管理方式：
页式管理：
![[Pasted image 20251227154121.png]]
将虚拟内存和物理内存分为若干大小固定的页面，然后通过页表建立从虚拟页面到物理页面的映射。

段式管理：
![[Pasted image 20251227154216.png]]
将程序的不同部分划分为不同的段，每个段在物理内存中不连续，但在逻辑上是连续的。

段页式管理：
![[Pasted image 20251227154313.png]]
首先将程序划分为逻辑上的段，再将段进一步划分为固定大小的页。

## 虚拟内存管理
### 页框分配
在虚拟内存管理中，页框分配是操作系统为进程分配物理内存（页框）的过程。它直接影响着系统的性能，因为分配的页框数量会影响进程的缺页率和系统的整体吞吐量。

驻留集：
![[Pasted image 20251227162011.png]]
驻留集（Resident Set）是指某个进程在执行过程中，当前实际存放在物理内存中的页面集合，反映了该进程在某一时刻真正占用并可直接访问的物理页。由于进程的地址空间往往远大于物理内存，操作系统通过虚拟存储管理来实现“用部分物理内存支撑完整逻辑地址空间”，而驻留集正是这个机制下进程能够被立即访问的物理页子集。

驻留集大小（Resident Set Size, RSS）则是度量该集合规模的指标，通常以页框（page frame）的数量来表示。它决定了进程可直接利用的物理内存范围，从而影响其运行效率。

合理设置驻留集大小对于系统性能至关重要：
- 过小：会频繁发生页面置换，导致缺页中断激增，系统性能显著下降。
- 过大：占用过多物理内存，可能挤压其他进程的生存空间，降低系统整体吞吐率。
因此，操作系统往往需要通过页面置换算法或局部/全局分配策略来动态调整驻留集大小，以在单个进程性能与系统整体资源利用之间取得平衡。

抖动：
是指操作系统中频繁发生的页面置换现象，即刚被换出的页面马上又要被换入内存，刚被换入的页面马上又要被换出外存，导致系统大部分时间都用于页面的换入换出，而真正用于进程运行的时间很少。
![[Pasted image 20251227162425.png]]
当系统为一个进程分配的物理内存不足以满足其工作集（当前活跃的页面集合）的需求时，就会频繁发生缺页中断。操作系统必须不停地从磁盘读取所需的页面到内存中，同时写出其他页面以释放空间。因为磁盘访问速度远慢于内存访问，这种频繁的磁盘I/O活动显著减慢了系统性能。

内存分配策略：
- 固定分配：
	- 内存划分为固定大小的区块。
	- 每个程序或进程分配一个或多个这样的区块，不管它们实际需要多少内存。
- 可变分配：
	- 内存根据每个程序的需求动态分配。
	- 当程序请求内存时，操作系统查看可用内存并分配刚好足够的内存空间给程序。
![[Pasted image 20251227220354.png]]

内存置换策略：
- 局部置换：在选择要换出的页面时，仅限于该进程自身拥有的内存页面范围内进行选择。
- 全局置换：可以在整个系统的内存页面范围内进行选择。
![[Pasted image 20251227220543.png]]
### 页置换算法：
在操作系统中，进程运行时，如果它要访问的页面不在内存中，就会产生缺页中断。这时，操作系统需要从磁盘中将该页面调入内存。但如果此时内存已满，操作系统就需要选择一个页面将其移出内存，以便为新页面腾出空间。这个选择要移出哪个页面的算法，就叫做页面置换算法。
1. 先进先出FIFO算法：
	总是先淘汰最先进入内存的页面，再把新增页面放入队列末尾。
2. 最佳页面置换OPT算法：
	理想状态的页面置换算法，预知未来驻留集中停留时间最短的页面（即未来引用次数最少的页面）将其替换。该算法只能用于性能评估和理论研究。
3. 近期最少使用LRU算法：
	选择最近一直没有被使用的页面进行替换，优先选择上次引用时间最早的页面。
4. 简单时钟Clock算法：
	更简单的LRU算法，硬件电路实现起来更高效。
	![[Pasted image 20251227221514.png]]
	初始情况下进程的所有页面都未被分配，所有页面的访问位都为 0。
	当一个新页面被添加时，时钟中的指针会不断旋转，直到找到一个访问位为 0 的页面将其替换。若当前页面的访问位为 1，则将其设置为 0，并移动到下一个位置进行查找。
	![[Pasted image 20251227221612.png]]
5. 改进时钟Clock算法：
	加入修改位的概念，现在每一个页面都有两个状态位：访问位（R），修改位（M）。
	按淘汰优先级分为四种类型：
	`(0,0)`：最近既没被访问，也没被修改。
	`(0,1)`：最近没有被访问，但被修改。
	`(1,0)`：最近被访问，但没被修改。
	`(1,1)`：最近被访问，且被修改。
6. 过去使用次数最少LFU算法：
	当页面第一次加载到内存中时，为其分配一个计数器，每次被访问时都会增加计数。
	当要替换页面时，选择计数器最小的页面替换。

### 内存映射文件：
将文件的全部或部分内容映射到进程的虚拟地址空间。
映射过程：
- 进程调用`mmap`，指定要映射的文件、偏移量、长度及访问权限。
- 操作系统在进程的虚拟地址空间中分配一段连续的虚拟内存，建立虚拟地址与文件内容的映射关系。
- 当进程访问这部分虚拟地址时，操作系统通过分页机制将文件内容加载到物理内存，并同步更新文件内容到磁盘。
优势：
- 减少数据拷贝
- 高效内存访问
- 延迟加载
- 支持进程间通信

# 文件管理
---
## 文件
在UNIX和类UNIX操作系统中，inode用于存储文件的大部分元信息，但不包括文件名和实际内容。
![[Pasted image 20251228002049.png]]
包括如下信息：
- 文件类型
- 权限
- 所有者
- 大小
- 时间戳
- 链接计数
- 数据块指针

### 进程文件管理
在进程运行并打开文件的途中，操作系统需要对打开的文件信息进行记录。需用到三个数据结构：
- 文件描述符表：每个进程都有自己的文件描述符表，记录该进程打开的文件描述符。
- 文件打开表：操作系统维护的一个全局的文件打开表，记录所有打开文件的状态信息。
- Inode表：包含文件的元数据和指向文件实际数据的指针。

inode表：
是一个固定的、专门的区域，用于存储文件系统中所有文件和目录的inode结构。每个inode编号对应一个唯一的文件或目录。是存储所有inode的唯一容器。
系统打开文件表：
整个操作系统内核维护的一个全局结构，记录所有进程当前打开的文件的状态信息。
文件描述符表：
是进程级别的表，将整数类型的文件描述符映射到系统打开文件表的条目上。即由文件描述符跳转到系统文件编号。
![[Pasted image 20251228122750.png]]
逻辑关系：
进程描述符表（进程级） → 系统文件打开表（系统级） → inode 表（系统级）
数据流向：
文件描述符表 → 文件描述符 → 系统打开文件表 → inode → inode表 → 文件元数据与数据块地址

系统调用：
在Unix操作系统中，无论是普通文件、设备文件，还是网络连接，操作系统都通过统一的机制进行管理——这套机制的核心，就是一组用于文件管理的系统调用。
`open`：
向内核申请访问权限，返回文件描述符，文件描述符会被存储到进程的文件描述符表中，并将系统文件打开表中的引用次数加1。如果文件是第一次被打开时，该文件的inode也会从外存中被加载到内存中。
`close`：
通知内核文件不再使用，可以释放相关资源。从文件描述符表删除文件描述符，将系统文件打开表的引用次数减1，若引用计数为0时内存中的inode会被释放。若程序未正确使用关闭指令将导致资源泄露。
`read`：
将文件内容从内核空间读取到用户缓冲区。
在Unix操作系统中，当系统识别到程序正在顺序读取文件时，会自动启用预读取机制，提前将后续的多个页加载到页缓存中，即使用户没有发出读取请求。
`write`：
将用户缓冲区的内容写入内核缓冲区。
在Unix操作系统中，写指令不会立刻将数据写入磁盘，而是将其暂存在内核的页缓存中，只有在特定的时机才会将缓存中的数据同一刷新到磁盘中。
`lessk`：
允许显式地移动文件的读写位置，实现随机访问。可以：跳过文件前面若干字节；返回文件开头重新读取；移动到文件末尾追加写入。使程序不仅能顺序处理数据，也能高效地实现定位的修改。

### 文件的逻辑结构
顺序文件：
将记录按一定顺序依次存储的文件逻辑结构。访问时采取顺序读取的方式，从文件开头依次读取每条记录，直到找到目标记录或读完整个文件。
随机文件：
记录随机存放在文件中，程序根据记录号、关键字等定位信息直接访问某条记录而不用逐条读取。

### 文件的物理结构
指文件在物理存储介质上的实际存放方式。
顺序文件：
- 连续结构
随机文件：
- 链式结构
- 文件分配表
- 索引分配
- 混合索引

连续分配：
每个文件占用磁盘上一个连续的块集。目录上记录文件的起始位置和分配块的数量。
![[Pasted image 20251228203725.png#center]]
优点：查找快速，访问快速。
缺点：内外部碎片化，内存利用效率低下，增加文件大小困难。

链式分配：
每个文件都是一个不需要连续的磁盘块链表。磁盘块可以分散在磁盘的任何地方。目录包含指向起始和结束文件块的指针。每个块包含一个指针指向下一个块。
![[Pasted image 20251228203940.png#center]]
优点：充分利用磁盘空间
缺点：访问速度慢

文件分配表FAT：
将文件的链接方式存储在一个表格中，一列是盘块号，另一列是该盘块下一个盘块的号码。
![[Pasted image 20251228204237.png#center]]
索引分配：
一个文件所占用的所有盘块号被存储在另一个盘块中，称为索引块。
在读取文件时，操作系统先读取索引块，确定存储文件的所有盘块号，再去读取所有有文件数据的盘块。
![[Pasted image 20251228204647.png#center]]
实际操作中还可以创建多级索引，使一个索引块指向下一级的索引块。
![[Pasted image 20251228204724.png#center]]
混合索引：
小文件使用直接块，把数据块的盘块号写入inode中的几个固定条目。
大文件使用多级索引进行间接寻址。
![[Pasted image 20251228204849.png#center]]
## 目录
### 目录的概念：
目录是计算机文件系统中用于组织和存储文件和其他目录的一种重要概念。目录也被称为文件夹，它是文件系统中的一个关键组成部分，用于创建层次结构，方便用户管理和浏览文件。

存储结构：
在文件系统中，目录本质上是一个特殊类型文件，内容是一个个目录项，用于记录当前目录下文件和子目录的名字及它们对应的inode编号。

操作：
目录的创建、移动、重命名、删除、列举。
文件的创建、移动、重命名、删除、复制、查看。
进入、返回指定目录，显示路径。

## 文件链接：
在linux文件系统中，一个文件的名字只是作为目录项中指向inode的指针。基于这点，可以为同一个文件创建多个名字，即为文件链接。
硬链接：
在文件系统的目录存储结构中，为同一个inode创建多个目录项。这些目录项分别对应不同的文件名，但是都指向同一个inode，共享同一份文件数据。
![[Pasted image 20251228220207.png#center]]
软链接：
在文件系统中创建一个特殊类型的文件，内容是指向目标文件路径的字符串。软链接自身拥有独立的inode和数据块，但并不直接指向目标文件的inode，而是通过路径进行间接访问。
![[Pasted image 20251228220343.png#center]]

## 文件系统
### 功能：
是操作系统和存储设备之间的桥梁，负责数据的存储、访问、管理和保护。
- 数据存储与组织
	- 以文件和目录的形式组织数据，将存储设备的物理空间划分为逻辑单元。
- 空间管理
	- 通过空闲块的管理高效利用存储空间。
- 数据访问与操作
	- 提供标准接口以支持对文件的访问和操作。
	- 确保数据的高效检索和修改。
- 数据保护和安全
	- 权限管理
	- 数据完整性校验

### 全局结构：
![[Pasted image 20251228220857.png]]
磁盘从逻辑上分为几个部分：
- 引导区MBR
	位于磁盘的起始位置，通常是磁盘的第一个扇区。它包含引导加载程序，用于引导操作系统。引导加载程序负责启动计算机并加载操作系统内核。
- 分区表
	通常存储在磁盘的第一个扇区之后，用于记录磁盘上的分区信息。指示了磁盘上每一个分区的起始位置、大小和文件系统类型。
- 分区
	存储有文件系统，包含元数据和数据区两部分。
	- 元数据
		- 超级块
			包含文件系统的关键信息，通常包含分区的块的数量、块的大小、空闲空间的管理方式。
		- 空闲块信息
			管理磁盘中空闲块的存储数据
		- inodes
			管理文件的元数据
	- 数据区
		存储实际的文件数据。是存储文件内容的地方。

### 外存空闲管理：
空闲表法：
系统需要维护一张空闲块表用以记录磁盘上尚未分配的连续空闲块的所在位置和大小。
空闲链表法：
采用链表结构组织和管理磁盘上的空闲数据块，每个节点对应一个空闲块，并在节点中记录该块所在的磁盘块号，同时有一个指针指向下一个空闲块。
分配时取出头节点并将头指针移动到下一个节点；回收时插入到链表表头。
位图法：
用二进制数组管理磁盘块。位图中的每一位对应磁盘上一个固定大小的数据块。位图中的每一位对应磁盘上一个固定大小的数据块，通过该位的取值判断该块的使用状态。
成组链接法：
![[Pasted image 20251228231828.png#center]]
使用一个磁盘块保存若干空闲盘块号，再用链表把这些块组织起来。

### 虚拟文件系统VFS
位于操作系统内核中的抽象层，为各种底层文件系统提供统一的访问入口。
VFS的核心目标：
![[Pasted image 20251228232046.png#center]]
- 统一接口
- 提升可扩展性
- 增强可移植性
VFS的工作流程：
1. 系统调用入口
2. VFS调度
3. 转发到具体实现
4. 结果返回

### 文件系统挂载
把一个独立的文件系统与操作系统的目录结构关联起来，使得该文件系统中的文件和目录能够被正常访问和管理。
![[Pasted image 20251228232434.png#center]]
1. 识别存储设备
2. 选择挂载点
3. 执行挂载操作
4. 管理与维护

# I/O管理
---
## I/O设备
### I/O接口类型
![[Pasted image 20251228232548.png]]
### I/O控制方式
- 程序查询方式：CPU不断价差外设状态是否准备好。
- 程序中断方式：外设设备就绪后向CPU发送中断信号，CPU暂停当前任务处理I/O操作。
- DMA方式：CPU只负责启动DMA控制器，数据传输过程由DMA独立完成。

### I/O软件层次
![[Pasted image 20251228232838.png]]
用户层I/O软件：
是I/O软件体系结构的最上层，直接与用户应用程序交互，提供标准化的接口以便程序访问I/O设备。
设备独立性软件：
屏蔽不同I/O设备的硬件差异，提供统一的接口给上层。提高系统的模块化和可移植性。
设备驱动程序：
针对特定类型的硬件设备设计，与具体硬件设备直接交互，负责将设备独立性软件的通用命令转换为设备能理解的特定指令。
中断处理程序：
用于处理硬件中断。
硬件：
直接负责执行物理I/O操作。

## 设备管理
### 缓冲区：
预留在内存中的区域，临时存放数据。

单缓冲：
只有一个缓冲区用于数据的读取和写入。
- 数据从源读入到单缓冲区。
- 数据在缓冲区内时，应用程序从该缓冲区中处理数据。
- 当应用程序处理完缓冲区的数据后，新的数据覆盖到同一片缓冲区中。
双缓冲：
使用两个缓冲区。当一个缓冲区进行读取或处理数据时，另一缓冲区可以用于并行的I/O操作。
- 数据从源读入到第一个缓冲区。
- 当第一个缓冲区正在被应用程序处理时，另一缓冲区可以开始并行地加载下一批数据。
- 当第一个缓冲区数据被处理完毕，应用程序切换到第二个缓冲区开始处理。
循环缓冲：
一个固定大小的缓冲区，其特点是当达到缓冲区的尾部时，下一个位置自动“回绕”到缓冲区的开始位置。
- 使用读和写两个标记指针。
- 新数据到来时，数据被写入写指针位置，并把写指针前移。
- 数据被读取时，数据从读指针位置读出，并把读指针前移。
- 两指针达到末尾时回到缓冲区开始位置。
缓冲池：
一组预先分配的缓冲区，这些缓冲区可以被系统中的多个进程或线程共享。
- 当进程需要缓冲区时，从缓冲区请求一个。如果没有可用的则会等待直到有可用的缓冲区。
- 进程使用完缓冲区后，将缓冲区返回到池中。

### 设备分配和回收
根据用户的I/O请求分配所需的设备。分配的原则是充分发挥设备的使用效率，尽可能地让设备忙碌，但又避免造成死锁。
- 独占式使用设备
- 分时共享使用设备
- 以SPOOLing方式使用外部设备

设备控制表DCT：
用于有效管理和访问外围设备，存储有关连接到系统的每个设备的信息。
![[Pasted image 20251229121147.png#center]]
设备分配方式：
- 静态分配：设备在程序开始执行时分配，执行完成后释放，不被其他进程共享。
- 动态分配：设备只在需要时被分配，不需要时立即释放。
分配安全性：
- 安全分配：不会造成死锁的分配方式
- 不安全分配：有可能造成死锁的分配方式
逻辑和物理设备映射：
- 逻辑设备名：符号化的标记设备的名称，面向用户和应用程序。
- 物理设备名：设备的底层标识，面向硬件。

逻辑设备表LUT：
将逻辑设备名映射到物理设备名的表。

### SPOOLing技术
联机并发外设操作，又称假脱机技术。将数据暂时存放在磁盘等中间存储区域，再由专门的后台程序将其送往目标外设。让 CPU 和外设之间的工作可以并行进行，互不等待。
![[Pasted image 20251229121632.png]]
关键机制：
- 中间存储区
	将所有要输出到外设的数据或从外设读取的数据保存到磁盘上的一个临时区域。
- 解耦与并行
	CPU无需等待外设完成操作，执行其他任务。外设可以在空闲时慢慢处理任务。
	主机和外设实现解耦，处理流程得以并行。
- 后台处理机制
	由系统后台的守护进程管理后续的执行，监管任务正常运行。

## 磁盘
### 磁盘管理
初始化：
在磁盘可以存储数据之前，必须进行物理格式化，也称低级格式化。
在磁盘的物理表面创建磁道、扇区、写入控制信息以及测试和标记坏扇区的过程。
分区：
在使用磁盘存储文件前需要将磁盘进行分区，并将每个分区的起始扇区和大小都记录在磁盘的主引导记录MBR的分区表中。
![[Pasted image 20251229122807.png]]
完成分区后对每个分区进行逻辑格式化，也称高级格式化。创建文件系统结构，使操作系统能够识别、组织和管理磁盘上的数据。主要包括元数据、分配表和目录结构等。
引导流程：
![[Pasted image 20251229133630.png]]
1. ROM：计算机加电后，ROM中的固件首先运行。初始化硬件，寻找可启动设备，并且指示磁盘控制器读取磁盘的第0号扇区（MBR）到内存。
2. MBR中的Bootloader：MBR的引导代码被ROM加载并执行，解析分区表，找到标有“活动分区”的引导分区，并加载该分区的第一个扇区。
3. 分区的启动扇区：活动分区的第一个扇区称为引导扇区，包含特定于操作系统的引导代码。MBR的Bootloader将控制权移交到引导扇区，进一步加载系统内核和必要组件，最后启动操作系统。
4. 操作系统初始化程序：操作权移交到操作系统的初始化程序，加载操作系统内核、加载设备驱动、初始化内存和硬件环境，然后将控制权传递给内核。

坏块：
随着时间推移，物理磁盘上出现的无法读写的区域。

### 机械硬盘调度算法
先来先服务FCFS：
最简单的调度算法，按照请求到达的先后顺序依次处理任务。
![[Pasted image 20251229134523.png#center]]
最短寻道时间优先SSTF：
每次都选择距离当前磁头位置最近的请求。
![[Pasted image 20251229134531.png#center]]
电梯调度SCAN：
磁头从一个方向开始移动，直到该方向上没有更多的请求或到达边界，然后磁头改变方向继续服务请求。
![[Pasted image 20251229134537.png#center]]
循环扫描C-SCAN：
磁头始终沿一个方向移动，同时处理沿途的请求，到达磁盘边界后立即返回到另一端。
![[Pasted image 20251229134544.png#center]]
